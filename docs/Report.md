Отчёт по лабораторной работе
ФИО: Дмитриченко Игорь Дмитриевич
Группа: ПРИ-0-25/1
Тема: Разработка консольного приложения для анализа частоты слов в JSON-данных на C++
*************************************************************************************
1. Краткое описание задачи и среды выполнения
Задача:
Разработать консольное приложение на C++, которое считывает JSON-файлы с текстом, анализирует частоту встречаемости слов, фильтрует стоп-слова и выводит статистику (топ-N слов) с замером производительности.

Среда выполнения:

Операционная система: Windows 11

IDE: Visual Studio Code

Компилятор: MSVC (C++17)

Библиотеки: nlohmann/json v3.11.3

Консоль: Windows Terminal с UTF-8 поддержкой
____________________________________________________________________________________
2. Структура проекта и схема данных
Структура проекта:

```text
WordFrequencyAnalyzer/
├──  main.cpp              # Главная логика + консольное меню
├──  data/                 # Тестовые JSON файлы (text_0.json → text_N.json)
├──  docs/                 # Документация (Implementation Plan, Report)
├──  README.md            # Инструкция по запуску
└── WordFrequency.exe       # Готовый исполняемый файл
```
Мини-спецификация JSON:

```json
{
  "text": "В начале было Слово и Слово было у Бога.",
  "stopwords": ["и", "в", "у"]
}
```
text — строка с текстом для анализа (обязательное)

stopwords — массив стоп-слов для фильтрации (опциональное)

3. Описание ключевых алгоритмов
Парсинг текста → подсчет частоты → сортировка топ-N:

splitWords() — stringstream разбивает текст по пробелам

Фильтрация стоп-слов — точное сравнение word == stop

std::map<string,int> — автоматический подсчет частоты

std::sort() — сортировка по убыванию популярности

Бенчмарк — chrono::high_resolution_clock для замера времени

UTF-8 обработка: Windows Terminal + SetConsoleCP(65001) + избегание tolower() на кириллице.

4. Выдержки из интерфейсов функций и примеры использования
```cpp
bool readJsonFile(const string& filename, json& data);           // Читает JSON файл
void generateJsonFiles(int count);                               // Генерирует text_0.json...text_N.json
void splitWords(const string& text, const vector<string>& stopwords, vector<string>& words_out);
void analyzeText(const json& data, bool timecheck, vector<string>& words, map<string,int>& freq, int fileIndex);
```
Пример использования:

```cpp
// Генерация 100 тестовых файлов
generateJsonFiles(100);

// Анализ первого файла
json data;
if (readJsonFile("text_0.json", data)) {
    vector<string> words;
    map<string,int> freq;
    analyzeText(data, false, words, freq, 0);
}
```
5. Обработка ошибок и UX взаимодействие
Обработка ошибок:

```text
 Не удалось открыть файл text_5.json
 файл text_3.json пуст, пропускаем  
 Ошибка парсинга JSON файла text_7.json: unexpected token
 Выберите 1, 2 или 3!
```
UX — консольное меню:

```text
================ АНАЛИЗАТОР ЧАСТОТЫ СЛОВ ================

1) Анализ файлов    2) Отладка    3) Выход
> 2
1) Генерация файлов    2) Бенчмарк
> 1
Количество файлов: 100
Создан файл text_0.json
...
```
6. Результаты тестов
Позитивные сценарии:

Сценарий	Результат
Корректный JSON Топ-5 слов, статистика, кириллица
Без стоп-слов. Все слова учтены
1000 файлов Бенчмарк 2453мс
Негативные сценарии:

Сценарий	Результат
Отсутствует файл "Не удалось открыть" + пропуск
Пустой файл "файл пуст, пропускаем"
Неверный JSON "Ошибка парсинга" + пропуск
7. Результаты бенчмарков
Тестирование на сгенерированных файлах:

|Количество файлов|	Время анализа (мс)|	Скорость (файл/с)|	Примечания |
--------------------------------------------------------------------
|10 |	23 |	434 файлы/с |	Базовая скорость |
|100 |	245	| 408 файлы/с |	Линейная зависимость | 
|1000 |	2453 |	407 файлы/с |	Стабильно | 
 Линейная зависимость O(N) подтверждена!

8. Выводы и предложения по улучшению
Достигнуто:

Полная UTF-8 поддержка кириллицы в Windows Terminal

Корректная работа с JSON (валидация + парсинг)

Линейная производительность O(N) для N файлов

Интуитивное консольное UX с эмодзи и цветами

Обработка всех типов ошибок (файлы, JSON, ввод)

Узкие места:

std::map — log(N) на вставку (можно заменить на unordered_map)

Последовательная обработка файлов (параллелизм возможен)

Предложения по улучшению:

```text
1. Параллельная обработка файлов (std::thread / OpenMP)
2. unordered_map вместо map (+30% скорости)
3. Экспорт результатов в JSON/CSV
4. Интерактивный выбор файлов (не только text_N.json)
5. Графики частотности (Matplotlib через Python)
```
